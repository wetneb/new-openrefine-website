"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[1112],{3905:(e,t,i)=>{i.d(t,{Zo:()=>p,kt:()=>u});var n=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function a(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function c(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var s=n.createContext({}),l=function(e){var t=n.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):a(a({},t),e)),i},p=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var i=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),h=l(i),u=r,d=h["".concat(s,".").concat(u)]||h[u]||f[u]||o;return i?n.createElement(d,a(a({ref:t},p),{},{components:i})):n.createElement(d,a({ref:t},p))}));function u(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=i.length,a=new Array(o);a[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,a[1]=c;for(var l=2;l<o;l++)a[l]=i[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,i)}h.displayName="MDXCreateElement"},8874:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>c,metadata:()=>l,toc:()=>f});var n=i(7462),r=i(3366),o=(i(7294),i(3905)),a=["components"],c={id:"reconciliation-api",title:"Reconciliation API",sidebar_label:"Reconciliation API"},s=void 0,l={unversionedId:"technical-reference/reconciliation-api",id:"version-3.5/technical-reference/reconciliation-api",title:"Reconciliation API",description:"This is a technical description of the mechanisms behind the reconciliation system in OpenRefine. For usage instructions, see Reconciliation.",source:"@site/versioned_docs/version-3.5/technical-reference/reconciliation-api.md",sourceDirName:"technical-reference",slug:"/technical-reference/reconciliation-api",permalink:"/new-openrefine-website/docs/3.5/technical-reference/reconciliation-api",draft:!1,editUrl:"https://github.com/OpenRefine/OpenRefine/edit/master/docs/versioned_docs/version-3.5/technical-reference/reconciliation-api.md",tags:[],version:"3.5",lastUpdatedBy:"Antonin Delpeuch",lastUpdatedAt:1662887291,formattedLastUpdatedAt:"Sep 11, 2022",frontMatter:{id:"reconciliation-api",title:"Reconciliation API",sidebar_label:"Reconciliation API"},sidebar:"version-3.5/docs",previous:{title:"OpenRefine API",permalink:"/new-openrefine-website/docs/3.5/technical-reference/openrefine-api"},next:{title:"Contributing",permalink:"/new-openrefine-website/docs/3.5/technical-reference/contributing"}},p={},f=[],h={toc:f};function u(e){var t=e.components,i=(0,r.Z)(e,a);return(0,o.kt)("wrapper",(0,n.Z)({},h,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"This is a technical description of the mechanisms behind the reconciliation system in OpenRefine. For usage instructions, see ",(0,o.kt)("a",{parentName:"em",href:"/manual/reconciling"},"Reconciliation"),".")),(0,o.kt)("p",null,"A reconciliation service is a web service that, given some text which is a name or label for something, and optionally some additional details, returns a ranked list of potential entities matching the criteria. The candidate text does not have to match each entity's official name perfectly, and that's the whole point of reconciliation--to get from ambiguous text name to precisely identified entities. For instance, given the text \"apple\", a reconciliation service probably should return the fruit apple, the Apple Inc. company, and New York city (also known as the Big Apple)."),(0,o.kt)("p",null,'Entities are identified by strong identifiers in some particular identifier space. In the same identifier space, identifiers follow the same syntax. For example, given the string "apple", a reconciliation service might return entities identified by the strings " ',(0,o.kt)("a",{parentName:"p",href:"https://www.wikidata.org/wiki/Q89"},"Q89"),'", "',(0,o.kt)("a",{parentName:"p",href:"https://www.wikidata.org/wiki/Q312"},"Q312"),'", and "',(0,o.kt)("a",{parentName:"p",href:"https://www.wikidata.org/wiki/Q60"},"Q60"),'", in the Wikidata ID space. Each reconciliation service can only reconcile to one single identifier space, but several reconciliation services can reconcile to the same identifier space.'),(0,o.kt)("p",null,"OpenRefine can connect to any reconciliation service which follows the ",(0,o.kt)("a",{parentName:"p",href:"https://reconciliation-api.github.io/specs/0.1/"},"reconciliation API v0.1"),". This was formerly a specification edited by the OpenRefine project, which has now transitioned to its own\n",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/community/reconciliation/"},"W3C Entity Reconciliation Community Group"),"."),(0,o.kt)("p",null,"Informally, the main function of any reconciliation service is to find good candidates in the underlying database, given the following data:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A string, which is normally the name or title of the entity, in some language."),(0,o.kt)("li",{parentName:"ul"},"Optionally, a type which can be used to narrow down the search to entities of this type. OpenRefine does not define a particular set of acceptable types: this choice is left to the reconciliation service (see the suggest API for that)."),(0,o.kt)("li",{parentName:"ul"},"Optionally, a list of properties and their values, which can be used to refine the search. For instance, when reconciling a database of books, the author name or the publication date are useful bits of information that can be transferred to the reconciliation service. This information will be sent to the reconciliation service if the user binds columns to properties. Again, the notion of property is not predefined in OpenRefine: its definition depends on the reconciliation service.")),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://reconciliation-api.github.io/specs/0.1"},"the specifications of the protocol")," for more details about the protocol. You can suggest changes on its ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/reconciliation-api/specs/issues"},"issues tracker")," or on the ",(0,o.kt)("a",{parentName:"p",href:"https://lists.w3.org/Archives/Public/public-reconciliation/"},"group mailing\nlist"),"."))}u.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[9942],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},787:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],s={},l=void 0,c={unversionedId:"manual/wikibase/advanced-schemas",id:"version-3.5/manual/wikibase/advanced-schemas",title:"advanced-schemas",description:"Sometimes your data is not as simple as a normal table, or the sort of",source:"@site/versioned_docs/version-3.5/manual/wikibase/advanced-schemas.md",sourceDirName:"manual/wikibase",slug:"/manual/wikibase/advanced-schemas",permalink:"/new-openrefine-website/docs/3.5/manual/wikibase/advanced-schemas",draft:!1,editUrl:"https://github.com/OpenRefine/OpenRefine/edit/master/docs/versioned_docs/version-3.5/manual/wikibase/advanced-schemas.md",tags:[],version:"3.5",lastUpdatedBy:"Antonin Delpeuch",lastUpdatedAt:1662887291,formattedLastUpdatedAt:"Sep 11, 2022",frontMatter:{}},u={},d=[{value:"Hierarchical data",id:"hierarchical-data",level:2},{value:"Conditional additions",id:"conditional-additions",level:2},{value:"Varying properties",id:"varying-properties",level:2},{value:"Adapting to existing data on Wikibase",id:"adapting-to-existing-data-on-wikibase",level:2}],p={toc:d};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Sometimes your data is not as simple as a normal table, or the sort of\nstatements that you want to do varies on each row. This document\nexplains how to work around these cases."),(0,r.kt)("h2",{id:"hierarchical-data"},"Hierarchical data"),(0,r.kt)("p",null,"Sometimes your source provides data in a structured format, such as XML,\nJSON or RDF. OpenRefine can import these files and will convert them to\ntables. These tables will reflect some of the hierarchy in the file by\nmeans of null cells, using the ",(0,r.kt)("a",{parentName:"p",href:"/manual/exploring#rows-vs-records"},"records mode"),"."),(0,r.kt)("p",null,"The Wikibase extension always works in rows mode, so if we want to add\nstatements which reference both the artist and the song, we need to fill\nthe null cells with the corresponding artist. You can do this with the\n",(0,r.kt)("strong",{parentName:"p"},"Fill down")," operation (in the ",(0,r.kt)("strong",{parentName:"p"},"Edit cells")," menu for this column).\nThis function will copy not just cell values but also reconciliation\nresults."),(0,r.kt)("h2",{id:"conditional-additions"},"Conditional additions"),(0,r.kt)("p",null,"Sometimes you want to add a statement only in some conditions."),(0,r.kt)("p",null,"The workflow to achieve this looks like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use facets to select the rows where you do not want to add any\ninformation;"),(0,r.kt)("li",{parentName:"ul"},"Blank out the cells in the column that contain the information you\nwant to add. If you do not want to lose this information, you can\ncreate a copy of the column beforehand;"),(0,r.kt)("li",{parentName:"ul"},"Remove your facets to see all rows again;"),(0,r.kt)("li",{parentName:"ul"},"Create a schema using the column you partially blanked out as\nstatement value.")),(0,r.kt)("h2",{id:"varying-properties"},"Varying properties"),(0,r.kt)("p",null,"Sometimes you wish you could use column variables for properties in your\nschema. It is currently not possible, first because we do not have a\nreconciliation service for properties yet, but also because allowing\nvarying properties in a statement would mean that these properties could\npotentially have different datatypes, which would break the structure of\nthe schema."),(0,r.kt)("p",null,"If you only want to use a few properties, there is a way to go around\nthis problem. For instance, say you have a first column of altitudes and a\nsecond column that indicates whether you should add it as\n",(0,r.kt)("a",{parentName:"p",href:"https://www.wikidata.org/wiki/Property:P2254"},"operating altitude (P2254)")," or as\n",(0,r.kt)("a",{parentName:"p",href:"https://www.wikidata.org/wiki/Property:P2044"},"elevation above sea level (P2044)"),"."),(0,r.kt)("p",null,"Create a text facet on the first column. Filter to keep only the\n",(0,r.kt)("em",{parentName:"p"},"altitude")," values. Add a new column based on the second column, by\nkeeping the default expression (",(0,r.kt)("inlineCode",{parentName:"p"},"value"),") which just copies the existing\nvalues. Then, select the ",(0,r.kt)("em",{parentName:"p"},"maximum operating altitude")," value in the facet\nand do the same. Reset the facet, you should have obtained two new columns\nwhich partition the original column. You can now create a schema which adds\ntwo statements, with values taken from those columns. Since blank values are\nignored, exactly one statement will be added for each item, with the desired property."),(0,r.kt)("h2",{id:"adapting-to-existing-data-on-wikibase"},"Adapting to existing data on Wikibase"),(0,r.kt)("p",null,"Sometimes you want to create statements only if there are no such\nstatements on the item yet. Here is one way to achieve this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"first, retrieve the existing values from Wikidata first, using the\n",(0,r.kt)("strong",{parentName:"li"},"Edit columns")," \u2192 ",(0,r.kt)("strong",{parentName:"li"},"Add columns from reconciled values")," action;"),(0,r.kt)("li",{parentName:"ul"},"second, create a ",(0,r.kt)("em",{parentName:"li"},"facet by null")," on the newly created column that\ncontains the information you want to control against;"),(0,r.kt)("li",{parentName:"ul"},"select the non-null rows (value ",(0,r.kt)("strong",{parentName:"li"},"false"),");"),(0,r.kt)("li",{parentName:"ul"},"clear the contents of the column where your source values are\n(",(0,r.kt)("strong",{parentName:"li"},"Edit cells")," \u2192 ",(0,r.kt)("strong",{parentName:"li"},"Common transformations")," \u2192 ",(0,r.kt)("strong",{parentName:"li"},"To null"),").")),(0,r.kt)("p",null,"You can now construct your schema as usual - null values will be ignored\nwhen generating the statements."))}m.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[9811],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),h=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=h(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=h(n),u=i,m=c["".concat(s,".").concat(u)]||c[u]||d[u]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var h=2;h<r;h++)o[h]=n[h];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8283:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>h,toc:()=>d});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],l={id:"clustering-in-depth",title:"Clustering Methods In-depth",sidebar_label:"Clustering methods in-depth"},s=void 0,h={unversionedId:"technical-reference/clustering-in-depth",id:"technical-reference/clustering-in-depth",title:"Clustering Methods In-depth",description:"Methods and theory behind the clustering functionality in OpenRefine.",source:"@site/docs/technical-reference/clustering-in-depth.md",sourceDirName:"technical-reference",slug:"/technical-reference/clustering-in-depth",permalink:"/new-openrefine-website/docs/next/technical-reference/clustering-in-depth",draft:!1,editUrl:"https://github.com/OpenRefine/OpenRefine/edit/master/docs/docs/technical-reference/clustering-in-depth.md",tags:[],version:"current",lastUpdatedBy:"Antonin Delpeuch",lastUpdatedAt:1662887291,formattedLastUpdatedAt:"Sep 11, 2022",frontMatter:{id:"clustering-in-depth",title:"Clustering Methods In-depth",sidebar_label:"Clustering methods in-depth"},sidebar:"docs",previous:{title:"Architecture",permalink:"/new-openrefine-website/docs/next/technical-reference/architecture"},next:{title:"OpenRefine API",permalink:"/new-openrefine-website/docs/next/technical-reference/openrefine-api"}},p={},d=[{value:"Key Collision Methods",id:"key-collision-methods",level:2},{value:"Fingerprint",id:"fingerprint",level:3},{value:"N-Gram Fingerprint",id:"n-gram-fingerprint",level:3},{value:"Phonetic Fingerprint",id:"phonetic-fingerprint",level:3},{value:"Metaphone3",id:"metaphone3",level:4},{value:"Cologne Phonetics",id:"cologne-phonetics",level:4},{value:"Daitch-Moktoff",id:"daitch-moktoff",level:4},{value:"Beider-Morse",id:"beider-morse",level:4},{value:"Nearest Neighbor Methods",id:"nearest-neighbor-methods",level:2},{value:"Levenshtein Distance",id:"levenshtein-distance",level:3},{value:"PPM",id:"ppm",level:3}],c={toc:d};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Methods and theory behind the clustering functionality in OpenRefine.")),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In OpenRefine, ",(0,r.kt)("a",{parentName:"p",href:"https://docs.openrefine.org/manual/cellediting#cluster-and-edit"},"clustering"),' refers to the operation of "finding groups of\ndifferent values that might be alternative representations of the same\nthing."'),(0,r.kt)("p",null,"It is worth noting that clustering in OpenRefine works only at the\nsyntactic level (the character composition of the cell value) and, while\nvery useful to spot errors, typos, and inconsistencies, it's by no means\nenough to perform effective semantically-aware reconciliation. This is\nwhy OpenRefine uses ",(0,r.kt)("a",{parentName:"p",href:"https://docs.openrefine.org/manual/reconciling"},"external semantically-aware reconciliation services"),"\n(such as Wikidata) to compensate for the deficiencies of syntax-level\nclustering alone."),(0,r.kt)("h1",{id:"methodologies"},"Methodologies"),(0,r.kt)("p",null,"To strike a balance between general applicability and\nusefulness, OpenRefine ships with a selected number of clustering\nmethods and algorithms that have proven effective and fast enough to use\nin a wide variety of situations."),(0,r.kt)("p",null,"OpenRefine currently offers 2 broad categories of clustering methods:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Token-based (n-gram, key collision, etc.)"),(0,r.kt)("li",{parentName:"ol"},"Character-based, also known as Edit distance (Levenshtein distance, PPM, etc.)")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE:"),"  Performance differs depending on the strings that you want to cluster in your data which might be short or very long or varying.  String complexity length has a large part to do with the algorithm that might perform faster (but not necessarily better!).  In general, it's usually best to use heavy algorithms for shorter strings that can provide better quality \u2013 like Levenshtein distance.  And token-based algorithms for longer strings such as n-grams(q-grams), bag distance, Jaccard similarity, Dice coefficient, etc. (some of which we do not provide currently)."),(0,r.kt)("h2",{id:"key-collision-methods"},"Key Collision Methods"),(0,r.kt)("p",null,'"Key Collision" methods are based on the idea of creating an alternative\nrepresentation of a value (a "key") that contains only the most valuable\nor meaningful part of the string and "buckets" (or "bin" as it\'s\ndescribed inside OpenRefine\'s code) together different strings based on\nthe fact that their key is the same (hence the name "key collision").'),(0,r.kt)("h3",{id:"fingerprint"},"Fingerprint"),(0,r.kt)("p",null,"The fingerprinting method is the least likely to produce false\npositives, which is why it is the default method."),(0,r.kt)("p",null,"The process that generates the key from a string value is the following\n(note that the order of these operations is significant):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"remove leading and trailing whitespace"),(0,r.kt)("li",{parentName:"ul"},"change all characters to their lowercase representation"),(0,r.kt)("li",{parentName:"ul"},"remove all punctuation and control characters"),(0,r.kt)("li",{parentName:"ul"},'normalize extended western characters to their ASCII representation\n(for example "g\xf6del" \u2192 "godel")'),(0,r.kt)("li",{parentName:"ul"},"split the string into whitespace-separated tokens"),(0,r.kt)("li",{parentName:"ul"},"sort the tokens and remove duplicates"),(0,r.kt)("li",{parentName:"ul"},"join the tokens back together")),(0,r.kt)("p",null,"If you're curious, the code that performs this is\n",(0,r.kt)("a",{parentName:"p",href:"http://github.com/OpenRefine/OpenRefine/blob/master/main/src/com/google/refine/clustering/binning/FingerprintKeyer.java"},"here"),"."),(0,r.kt)("p",null,"Several factors play a role in this fingerprint:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"because whitespace is normalized, characters are lowercased, and\npunctuation is removed, those parts don't play a differentiation\nrole in the fingerprint. Because these attributes of the string are\nthe least significant in terms of meaning differentiation, these\nturn out to be the most varying parts of the strings, and removing\nthem has a substantial benefit in emerging clusters."),(0,r.kt)("li",{parentName:"ul"},'because the string parts are sorted, the given order of tokens\ndoesn\'t matter (so "Cruise, Tom" and "Tom Cruise" both end up with a\nfingerprint "cruise tom" and therefore end up in the same cluster)'),(0,r.kt)("li",{parentName:"ul"},'normalizing extended western characters plays the role of\nreproducing data entry mistakes performed when entering extended\ncharacters with an ASCII-only keyboard. Note that this procedure can\nalso lead to false positives. For example, "g\xf6del" and "god\xe9l" would\nboth end up with "godel" as their fingerprint, but they\'re likely to\nbe different names, so this might work less effectively for datasets\nwhere extended characters play a substantial differentiation role.')),(0,r.kt)("h3",{id:"n-gram-fingerprint"},"N-Gram Fingerprint"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/N-gram"},"n-gram")," fingerprint method does the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"change all characters to their lowercase representation"),(0,r.kt)("li",{parentName:"ul"},"remove all punctuation, whitespace, and control characters"),(0,r.kt)("li",{parentName:"ul"},"obtain all the string n-grams"),(0,r.kt)("li",{parentName:"ul"},"sort the n-grams and remove duplicates"),(0,r.kt)("li",{parentName:"ul"},"join the sorted n-grams back together"),(0,r.kt)("li",{parentName:"ul"},"normalize extended western characters to their ASCII representation")),(0,r.kt)("p",null,'So, for example, the 2-gram fingerprint of "Paris" is "arispari" and the\n1-gram fingerprint is "aiprs".'),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"http://github.com/OpenRefine/OpenRefine/blob/master/main/src/com/google/refine/clustering/binning/NGramFingerprintKeyer.java"},"Check the code"),"\nif you're curious about the details."),(0,r.kt)("p",null,"Why is this useful? In practice, using big values for n-grams doesn't\nyield any advantage over the previous fingerprint method, but using\n2-grams and 1-grams, while yielding many false positives, can find\nclusters that the previous method didn't find even with strings that\nhave small differences, with a very small performance price."),(0,r.kt)("p",null,'For example "Krzysztof", "Kryzysztof", and "Krzystof" have different\nlengths and different regular fingerprints, but share the same 1-gram\nfingerprint because they use the same letters.'),(0,r.kt)("h3",{id:"phonetic-fingerprint"},"Phonetic Fingerprint"),(0,r.kt)("p",null,"Phonetic fingerprinting is a way to transform tokens into the way they are\npronounced. This is useful to spot errors that are due to people\nmisunderstanding or not knowing the spelling of a word after only\nhearing it. The idea is that similar-sounding words will end up\nsharing the same key and thus being binned in the same cluster."),(0,r.kt)("p",null,'For example, "Reuben Gevorkiantz" and "Ruben Gevorkyants" share the same\nphonetic fingerprint for English pronunciation but they have different\nfingerprints for both the regular and n-gram fingerprinting methods\nabove, no matter the size of the n-gram.'),(0,r.kt)("p",null,'OpenRefine supports multiple "Phonetic" algorithms including:'),(0,r.kt)("h4",{id:"metaphone3"},"Metaphone3"),(0,r.kt)("p",null,"Metaphone3 improves phonetic encoding for not just words in the English Language but also non-English words, first names, and last names common in the United States."),(0,r.kt)("p",null,"The 'approximate' aspect of the encoding for OpenRefine (version 2.1.3) is implemented according to the following rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All vowels are encoded to the same value - 'A'.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the parameter ",(0,r.kt)("em",{parentName:"p"},"encodeVowels")," is set to false, only ",(0,r.kt)("em",{parentName:"p"},"initial")," vowels will be encoded at all.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"encodeVowels")," is set to true, 'A' will be encoded at all places in the word that any vowels are normally pronounced.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"'W', as well as 'Y', are treated as vowels. Although there are differences in their pronunciation in different circumstances that lead to their being classified as vowels under some circumstances and as consonants in others, for the 'fuzziness' component of the Soundex and Metaphone family of algorithms they will be always be treated here as vowels.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Voiced and un-voiced consonant pairs are mapped to the same encoded value. That is:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"'D' and 'T' -> 'T'"),(0,r.kt)("li",{parentName:"ul"},"'B' and 'P' -> 'P'"),(0,r.kt)("li",{parentName:"ul"},"'G' and 'K' -> 'K'"),(0,r.kt)("li",{parentName:"ul"},"'Z' and 'S' -> 'S'"),(0,r.kt)("li",{parentName:"ul"},"'V' and 'F' -> 'F'"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In addition to the above voiced/unvoiced rules, 'CH' and 'SH' -> 'X', where 'X' represents the \"-SH-\" and \"-CH-\" sounds in Metaphone 3 encoding.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Also, the sound that is spelled as \"TH\" in English is encoded to '0' (zero)."))),(0,r.kt)("h4",{id:"cologne-phonetics"},"Cologne Phonetics"),(0,r.kt)("p",null,"Cologne Phonetics, also called K\xf6lner Phonetik, is a phonetic algorithm that assigns a sequence of digits (called the ",(0,r.kt)("strong",{parentName:"p"},"phonetic code"),") to words."),(0,r.kt)("p",null,"Unlike Metaphone3, Cologne Phonetics is optimized for the German language."),(0,r.kt)("p",null,"The process of encoding words using Cologne phonetics can be broken down to the following steps:\n",(0,r.kt)("strong",{parentName:"p"},"Step 1:")),(0,r.kt)("p",null,"The encoding process is as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The word is preprocessed. That is,",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"conversion to upper case"),(0,r.kt)("li",{parentName:"ul"},"transcription of germanic umlauts"),(0,r.kt)("li",{parentName:"ul"},"removal of non-alphabetical characters")))),(0,r.kt)("p",null,"-The letters are then replaced by their phonetic codes according to the following table:"),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Letter"),(0,r.kt)("th",null,"Context"),(0,r.kt)("th",null,"Code"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"A, E, I, O, U"),(0,r.kt)("td",null," "),(0,r.kt)("td",null,"0")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"H"),(0,r.kt)("td",null),(0,r.kt)("td",null,"-")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"B"),(0,r.kt)("td",null),(0,r.kt)("td",{rowspan:"2"},"1")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"P"),(0,r.kt)("td",null,"not before H")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"D, T"),(0,r.kt)("td",null,"not before C, S, Z"),(0,r.kt)("td",null,"2")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"F, V, W"),(0,r.kt)("td",null),(0,r.kt)("td",{rowspan:"2"},"3")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"P"),(0,r.kt)("td",null,"before H")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"G, K, Q"),(0,r.kt)("td",null),(0,r.kt)("td",{rowspan:"3"},"4")),(0,r.kt)("tr",null,(0,r.kt)("td",{rowspan:"2"},"C"),(0,r.kt)("td",null,"at onset before A, H, K, L, O, Q, R, U, X")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"before A, H, K, O, Q, U, X except after S, Z")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"X"),(0,r.kt)("td",null,"not after C, K, Q"),(0,r.kt)("td",null,"48")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"L"),(0,r.kt)("td",null),(0,r.kt)("td",null,"5")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"M, N"),(0,r.kt)("td",null),(0,r.kt)("td",null,"6")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"R"),(0,r.kt)("td",null),(0,r.kt)("td",null,"7")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"S, Z"),(0,r.kt)("td",null),(0,r.kt)("td",{rowspan:"6"},"8")),(0,r.kt)("tr",null,(0,r.kt)("td",{rowspan:"3"},"C"),(0,r.kt)("td",null,"after S, Z")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"at onset except before A, H, K, L, O, Q, R, U, X")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"not before A, H, K, O, Q, U, X")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"D, T"),(0,r.kt)("td",null,"before C, S, Z")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"X"),(0,r.kt)("td",null,"after C, K, Q")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"For example"),'\nFollowing the rules stated above, the phrase "Good morning" in German could be encoded as:'),(0,r.kt)("p",null,"Guten Morgen -> GUTENMORGEN -> 40206607406"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 2:")),(0,r.kt)("p",null,"Any consecutive duplicate digit is removed"),(0,r.kt)("p",null,"4020",(0,r.kt)("strong",{parentName:"p"},"66"),"07406 -> 4020607406"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 3:")),(0,r.kt)("p",null,'Removal of all codes "0" ',(0,r.kt)("strong",{parentName:"p"},"except")," at the beginning."),(0,r.kt)("p",null,"4",(0,r.kt)("strong",{parentName:"p"},"0"),"2",(0,r.kt)("strong",{parentName:"p"},"0"),"6",(0,r.kt)("strong",{parentName:"p"},"0"),"74",(0,r.kt)("strong",{parentName:"p"},"0"),"6 -> 426746"),(0,r.kt)("p",null,"Hence, by the Cologne phonetic, Guteng Morgen is encoded as 426746"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),' that two or more identical consecutive digits can occur if they occur after removing the "0" digits.'),(0,r.kt)("h4",{id:"daitch-moktoff"},"Daitch-Moktoff"),(0,r.kt)("p",null,"The Daitch-Moktoff phonetic algorithm was created by  Randy Daitch and Gary Mokotoff of the Jewish Genealogical Society (New York), hence its name."),(0,r.kt)("p",null,"It is a refinement of the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Soundex"},"Soundex")," algorithms designed to allow greater accuracy in matching Slavic and Yiddish surnames with similar pronunciation but differences in spelling."),(0,r.kt)("p",null,"The rules for converting surnames into D-M codes are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Names are coded to six digits, each digit representing a sound listed in the ",(0,r.kt)("a",{parentName:"li",href:"https://www.jewishgen.org/infofiles/soundex.html"},"coding chart")),(0,r.kt)("li",{parentName:"ul"},"When a name lacks enough coded sounds for six digits, use zeros to fill to six digits."),(0,r.kt)("li",{parentName:"ul"},"The letters A, E, I, O, U, J, and Y are always coded at the beginning of a name as in Alice.  In any other situation, they are ignored except when two of them form a pair and the pair comes before a vowel, as in Isaiah but not Freud."),(0,r.kt)("li",{parentName:"ul"},"The letter H is coded at the beginning of a name, as in Haber, or preceding a vowel, as in Manheim, otherwise, it is not coded."),(0,r.kt)("li",{parentName:"ul"},"When adjacent sounds can combine to form a larger sound, they are given the code number of the larger sound.  Mintz is not coded MIN-T-Z but MIN-TZ."),(0,r.kt)("li",{parentName:"ul"},"When adjacent letters have the same code number, they are coded as one sound, as in TOPF, which is not coded TO-P-F but TO-PF.  Exceptions to this rule are the letter combinations MN and NM, whose letters are coded separately, as in Kleinman."),(0,r.kt)("li",{parentName:"ul"},'When a surname consists of more than one word, it is coded as if one word, such as "Ben Aron", is treated as "Benaron".'),(0,r.kt)("li",{parentName:"ul"},"Several letters and letter combinations pose the problem that they may sound in one of two ways.  The letter and letter combinations CH, CK, C, J, and RS are assigned two possible code numbers.")),(0,r.kt)("h4",{id:"beider-morse"},"Beider-Morse"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://stevemorse.org/phonetics/bmpm.htm"},"Beider-Morse Phonetic Matching")," (BMPM) is a very intelligent algorithm, compared to ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Metaphone"},"Metaphone"),", whose purpose is to match names that are phonetically equivalent to the expected name. However,  unlike ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Soundex"},"soundex")," methods, the \u201csounds-alike\u201d test is based not only on the spelling but on the linguistic properties of various languages."),(0,r.kt)("p",null,"The steps for comparison are as follows:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 1:")," Determines the language from the spelling of the name"),(0,r.kt)("p",null,"The spelling of a name can include some letters or letter combinations that allow the language to be determined. Some examples are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"tsch", final "mann" and "witz" are specifically German')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'final and initial "cs" and "zs" are necessarily Hungarian')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"cz", "cy", initial "rz" and "wl", final "cki", letters "\u015b", "\u0142" and "\u017c" can be only Polish'))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 2:")," Applies phonetic rules to identify the language and translates the name into phonetic alphabets"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 3:")," Calculating the Approximate Phonetic Value"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 4:")," Calculating the Hebrew Phonetic Value"),(0,r.kt)("p",null,"The entire process is described in detail in this ",(0,r.kt)("a",{parentName:"p",href:"https://stevemorse.org/phonetics/bmpm.htm"},"document")),(0,r.kt)("h2",{id:"nearest-neighbor-methods"},"Nearest Neighbor Methods"),(0,r.kt)("p",null,"While key collisions methods are very fast, they tend to be either too\nstrict or too lax with no way to fine-tune how much difference between\nstrings we are willing to tolerate."),(0,r.kt)("p",null,"The\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm"},"Nearest Neighbor"),"\nmethods (also known as kNN), on the other hand, provide a parameter (the\nradius or ",(0,r.kt)("inlineCode",{parentName:"p"},"k"),") which represents a distance threshold: any pair of\nstrings that are closer than a certain value will be binned together."),(0,r.kt)("p",null,"Unfortunately, given n strings, there are ",(0,r.kt)("inlineCode",{parentName:"p"},"n(n-1)/2")," pairs of strings\n(and relative distances) that need to be compared and this turns out to\nbe too slow even for small datasets (a dataset with 3000 rows require\n4.5 million distance calculations","!",")."),(0,r.kt)("p",null,"We have tried various methods to speed up this process but the one that\nworks the best is called 'blocking' and is, in fact, a hybrid between\nkey collision and kNN. This works by performing a first pass over the\nsequence of strings to evaluate and obtain 'blocks' in which all strings\nshare a substring of a given 'blocking size' (which defaults to 6 chars\nin OpenRefine)."),(0,r.kt)("p",null,"Blocking doesn't change the computational complexity of the kNN method\nbut drastically reduces the number of strings that will be matched\nagainst one another (because strings are matched only inside the block\nthat contains them). So instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"n(n-1)/2")," we now have ",(0,r.kt)("inlineCode",{parentName:"p"},"nm(m-1)/2"),"\nbut ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is the number of blocks and ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," is the average size of the\nblock. In practice, this turns out to be dramatically faster because the\nblock size is comparable to the number of strings and the blocks are\nnormally much smaller. For example, for 3000 strings, you can have a\nthousand blocks composed of 10 strings each, which requires 45k\ndistances to calculate instead of 4.5M","!"),(0,r.kt)("p",null,"If you're not in a hurry, OpenRefine lets you select the size of the\nblocking substring and you can lower it down to 2 or 1 and make sure\nthat blocking is not hiding a potential pair from your search...\nalthough in practice, anything lower than 3 normally turns out to be a\nwaste of time."),(0,r.kt)("p",null,"All the above is shared between all the kNN methods, the difference of\noperation lies in the method used to evaluate the distance between the\ntwo strings."),(0,r.kt)("p",null,"For kNN distances, we found that blocking with less than 3 or 4 chars explodes the amount of time clustering takes and yields very few new valuable results, but your mileage may vary."),(0,r.kt)("h3",{id:"levenshtein-distance"},"Levenshtein Distance"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Levenshtein_distance"},"Levenshtein"),"\ndistance (also known as \"edit distance\") is probably the simplest and\nmost intuitive distance function between strings and is often still very\neffective due to its general applicability. It measures the minimal number of ' edit operations ' that are required to\nchange one string into the other."),(0,r.kt)("p",null,"It's worth noting that there are many flavors of edit-based distance\nfunctions (say, the\n",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance"},"Damerau-Levenshtein distance"),",\nwhich considers 'transposition' as a single operation) but in practice,\nfor clustering purposes, they tend to be equally functional (as long as\nthe user has control over the distance threshold)."),(0,r.kt)("h3",{id:"ppm"},"PPM"),(0,r.kt)("p",null,"This distance is an implementation of\n",(0,r.kt)("a",{parentName:"p",href:"http://arxiv.org/abs/cs/0111054"},"a seminal paper")," about the use of\nthe\n",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Kolmogorov_complexity"},"Kolmogorov complexity"),"\nto estimate 'similarity' between strings and has been widely applied to\nthe comparison of strings originating from DNA sequencing."),(0,r.kt)("p",null,"The idea is that because text compressors work by estimating the\ninformation content of a string, if two strings A and B are identical,\ncompressing A or compressing A+B (concatenating the strings) should\nyield very little difference (ideally, a single extra bit to indicate\nthe presence of the redundant information). On the other hand, if A and\nB are very different, compressing A and compressing A+B should yield\ndramatic differences in length."),(0,r.kt)("p",null,"OpenRefine uses a normalized version of the algorithm, where the\ndistance between A and B is given by"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"   d(A,B) = comp(A+B) + comp(B+A) / (comp(A+A) + comp(B+B));\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"comp(s)")," is the length of bytes of the compressed sequence of the\nstring ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," is the append operator. This is used to account for\ndeviation in the optimality of the given compressors."),(0,r.kt)("p",null,"While many different compressors can be used, the closer to Kolmogorov\noptimality they are (meaning, the better they encode) the more effective\ntheir result."),(0,r.kt)("p",null,"For this reason, we have used\n",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Prediction_by_Partial_Matching"},"Prediction by Partial Matching"),"\nas the compressor algorithm as it is one of the most effective\ncompression algorithms for text and works by performing statistical\nanalysis and predicting what character will come next in a string."),(0,r.kt)("p",null,"In practice, this method is very lax even for small radius values and\ntends to generate many false positives, but because it operates at a\nsub-character level it is capable of finding substructures that are not\neasily identifiable by distances that work at the character level. So it\nshould be used as a 'last resort' clustering method; that's why it is\nlisted last here despite its phenomenal efficacy in other realms."),(0,r.kt)("p",null,"It is also important to note that in practice similar distances are\nmore effective on longer strings than on shorter ones; this is mostly an\nartifact of the need for the statistical compressors to 'warm up' and\ngather enough statistics to start performing well."),(0,r.kt)("h1",{id:"cluster-new-value-suggestions"},"Cluster New Value Suggestions"),(0,r.kt)("p",null,"For each cluster identified, one value is chosen as the initial 'New\nCell Value' to use as the common value for all values in the cluster.\nThe value chosen is the first value in the Cluster: see the\n",(0,r.kt)("inlineCode",{parentName:"p"},"ClusteringDialog.prototype.\\_updateData")," function in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/OpenRefine/OpenRefine/blob/master/main/webapp/modules/core/scripts/dialogs/clustering-dialog.js"},"/main/webapp/modules/core/scripts/dialogs/clustering-dialog.js"),"."),(0,r.kt)("p",null,"The first value in the Cluster is determined by two steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) The order of the items in the Cluster as the Cluster is built"),(0,r.kt)("li",{parentName:"ul"},"b) The order of the items in the Cluster after sorting by the count\nof the occurrences of each value")),(0,r.kt)("p",null,"(a) is achieved via a Collections.sort - which is ",(0,r.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List,%20java.util.Comparator)"},'"guaranteed to be stable: equal elements will not be reordered as a result of the sort."'),(0,r.kt)("br",null),"\n(b) is achieved by different methods depending on whether you are doing a Nearest Neighbour or Key Collisions (aka Binning) cluster"),(0,r.kt)("p",null,"If you are using Key Collision/Binning then the Cluster is created using a TreeMap which by default ",(0,r.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html"},'"is sorted according to the natural\nordering of its keys"'),".",(0,r.kt)("br",null),"\nThe key is the string in the cell - so that means it will sort by the natural ordering of the strings in the cluster - which means that it\nuses a ",(0,r.kt)("a",{parentName:"p",href:"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#compareTo%28java.lang.String%29"},"'lexicographical' order")," - basically based on the Unicode values in the string"),(0,r.kt)("p",null,"If you are using the Nearest Neighbour sort the Cluster is created in a different way which is (as yet) undocumented. Testing indicates that it may be something like reverse natural ordering."),(0,r.kt)("h1",{id:"contribute"},"Contribute"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We've been focusing mostly on English content or data ported to\nEnglish. We know some of the methods might be biased towards it but\nwe're willing to introduce more methods\nonce the OpenRefine community gathers more insights into these\nproblems;"),(0,r.kt)("li",{parentName:"ul"},"OpenRefine's internals support a lot more methods but we have turned\noff many of them because they don't seem to have much practical\nadvantage over the ones described here. If you think that\nOpenRefine should use other methods, feel free to suggest them to us\nbecause we might have overlooked them.")),(0,r.kt)("h1",{id:"suggested-reading"},"Suggested Reading"),(0,r.kt)("p",null,"A lot of the code that OpenRefine uses for clustering originates from\nresearch done by the ",(0,r.kt)("a",{parentName:"p",href:"http://simile.mit.edu/"},"SIMILE Project")," at MIT\nwhich later\n",(0,r.kt)("a",{parentName:"p",href:"http://code.google.com/p/simile-vicino/"},"graduated as the Vicino project"),"\n('vicino', pronounced \"vitch-ee-no\", means 'near' in Italian)."),(0,r.kt)("p",null,"For more information on clustering methods and related research we\nsuggest you look at the\n",(0,r.kt)("a",{parentName:"p",href:"http://code.google.com/p/simile-vicino/source/browse/#svn/trunk/papers"},"bibliography of the Vicino project"),"."))}u.isMDXComponent=!0}}]);